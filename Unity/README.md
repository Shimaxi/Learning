# Unityでよく使うコードなどをまとめたもの

私がUnityを使っていて『このコマンドよく書くな』だったり、『この概念覚えて置きたいな』だったりするものを忘れないように記録しておくために作ったmdファイルです。

# Unityの基本
Unityはオブジェクトの配置を視覚的に見やすくし、直感的に扱いやすくする点が特徴で、オブジェクトにスクリプトを貼り付けることで、感覚的に思った通りの動作を実現出来る点が優れています。

なので、基本は『オブジェクトを画面上に配置する』→『それにスクリプトをアタッチする』というのを繰り返していくことになります。

そして、それら全体を「GameManager」のようなスクリプト(オブジェクト)で統括するのが基本の動作です。

以下は目的別でやり方やスクリプトなどについて説明していきます。

# 重要なクラス(GameObject,Transform)
## GameObject
Unityで作るオブジェクトが必ず持つ基礎となるクラスです。というよりオブジェクト自体がGameObjectと言って良いのかもしれません。
基本動作としては

- gameObject.SetActive(bool) //このGameObjectを表示するかどうか
- gameObject.GetComponent<T>() //このGameObjectについているComponentを取得
- gameObject.AddComponent<T>() //このGameObjectにComponentを追加

などがあります。「Component」というのは以下でも説明しますが、簡単に言うと、インスペクターに表示されている物達のことです。

componentの説明は以下で行います。

## Transform
Transformも基本的に全てのオブジェクトが持ちます(UIはRectTransformというものになっていますが)。意味は簡単に言うと「場所」のことで、オブジェクト自体を移動させたり、回転させたりと様々なことが出来ます。

それ以外にも

- transform.Find("Child") //このオブジェクトの子から引数と同じ名前を持つオブジェクトを探し、Transformを取得する。

- transform.Find("Child").gameObject //このオブジェクトの子から引数と同じ名前を持つオブジェクトを探し、GameObjectを取得する。

このように「.Find」関数で子オブジェクトからだけ検索して持ってこれるのがとても便利です。

> 【初心者Unity】Transform.Findとは？GameObject.Findとの違いは？https://tech.pjin.jp/blog/2022/1/24/unity-transform_find/


# スクリプトにおけるアクセス修飾子(public,private,SerializeField)
Unityでは変数宣言を行う際
```c#
public int number;
private string mojiretu;
[SerializeField] private character moji;
```
のように、変数宣言の前に謎の文字列を入れることがしばしばあります。これがアクセス修飾子です。

## publicとprivateの違い
Unityにおいては「public」とすると、その変数がインスペクターに表示されるようになります。「private」では表示されません。

インスペクターに表示されると、数値であればインスぺクターから値を変更でき、オブジェクトであればインスペクターにドラッグ＆ドロップすることでアタッチが出来ます。

またpublicに設定すると別の関数から変数を呼び出すことが出来るようになります。ボタンを押された時の動作を設定したい場合も「public void Kansu()」などとすることで、ボタンから関数を呼び出すことが出来ます。

一方で「private」に設定した場合はそれが出来ず、そのスクリプト内でしか値を変更することが出来ません。

特に理由が無ければ、他の関数から変数を呼び出されるのは凄い嫌なのでprivateとしたほうが良いです。しかし、そうするとインスペクター上に表示されなくなってしまい、オブジェクトのアタッチなどを行うことが出来なくなってしまいます。

その際に役に立つのが「[SerializeField]」です。これを付けてあげることによって、『他の関数から値は操作できないけど、インスペクターに表示され、インスペクター上からは操作が出来たり、オブジェクトをアタッチ出来る』ようになります。

これを上手く使い分けることがチーム作業の鍵かもしれません。

# Componentの操作
ここではスライダーを例に、スライダーの値を変更する方法について説明します。

まず、空のオブジェクトを作り、Inspectorを見て右下の「Add Component」というボタンを押します。そして、検索欄に「Slider」と入れて出てきた物をクリックすると、オブジェクトに「Slider」というComponentが追加されます。

こののComponentを見ると、このようにいくつかの設定事項があります。

これらは全てをスクリプトから操作することが可能です。

例えば、Sliderのvalueを変更したい場合。
```c#
public Slider sliderTest;

void Start(){
    sliderTest.value = 0.0;
}
```
別のオブジェクトに上のコードを記載したスクリプトをアタッチし、インスペクターに表示された「Slider Test」と書かれた部分にSliderのcomponentを持つオブジェクトをアタッチし、実行すると、Sliderのvalueが0になることが確認できます。(Sliderの場合は値の変更と同時にSliderの値も変わるので、スライダーが動くので確認できます。)

このようにして、『Componentを持つオブジェクトをアタッチする』→『アタッチされた関数内で値を変更する』というようにして、操作していくのが基本となります。

説明ややこしいけど、やれば直観的に分かると思います。

## Componentについてより詳しく
Componentは変数(int,string等々)と同じレイヤーに存在するものです(このあたりもっとちゃんと理解したい)。なので、上の例で示したように変数宣言と同じようにcomponentを宣言することで、扱うことが出来ます。違いと言えば、しっかりとInspectorの方で宣言したcomponentがどこにあるかを教えてあげなくてはいけないということぐらいでしょうか。


# Prefabsを作りたい
Unityを使っていると同じようなオブジェクト(だけど少しだけ違う物)を沢山配置したい！と思うことがしばしばあります。そこで用いるのがPrefabという概念です。

Prefab化されたオブジェクトは
```c#
Instantiate({prefab}, Transform, false);
```
とすることで、Transformで指定した場所に発生させることが出来ます。

prefab化のやり方は簡単で、Hierarchy上にあるオブジェクトをProjectフォルダにドラッグ&ドロップするだけです。

## Prefabで出来ないこと
Prefab化すると、Hierarchy上にあるオブジェクトをpublic変数にアタッチすることが出来なくなります。
そのため、解決方法として、Prefab内に事前にスクリプト等をcomponentとして設定しておき、そこからアタッチするという手があります。

# Monobehaviorって何？

UnityでC#のスクリプトを書こうとすると必ず出てくる「Monobehavior」という謎の単語、これは一体何なのだろうか。

```c#
public class 自作Component : MonoBehaviour  {
```
というようになっていますが、これは
```c#
class 派生クラス : 継承元クラス
```
簡単に言うとこういう事になります。
「継承」とは「機能を引き継ぐことができる機能」のことで、こうすることで、自分が作ったComponentでMonobehaviorが持っている機能を使えるようになります。

具体的に言うと、
- ①Awakeメソッド
- ②Startメソッド
- ③OnEnableメソッド
- ④OnDisableメソッド
- ⑤Updateメソッド
- ⑥OnDestroyメソッド

のような機能が使えるようになったり、GameObjectにこのComponentを追加できるようになります。

Unityのほとんどの機能はこれを前提としているので、ゲームの画面内で扱いたいものであれば必ず書く必要があります。

# コルーチン : 処理の中断と再開

# RectTransformについてちょっとだけ
Inspectorの左のマークは「alt」キーを押しながらだと、オブジェクトの位置を画像の通りに動かすことが出来ます。

